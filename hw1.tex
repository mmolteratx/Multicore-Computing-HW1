\documentclass{article}

\usepackage[english]{babel}
\usepackage{lineno, blindtext}
\usepackage[utf8]{inputenc}
\usepackage{amsmath,amssymb}
\usepackage{parskip}
\usepackage{enumitem}
\usepackage{listings}
\usepackage{graphicx}
\usepackage[ruled,vlined]{algorithm2e}
%\usepackage{algorithmic}
%\usepackage{algpseudocode}

% Margins
\usepackage[top=2.5cm, left=3cm, right=3cm, bottom=4.0cm]{geometry}
% Colour table cells
\usepackage[table]{xcolor}

% Get larger line spacing in table
\newcommand{\tablespace}{\\[1.25mm]}
\newcommand\Tstrut{\rule{0pt}{2.6ex}}         % = `top' strut
\newcommand\tstrut{\rule{0pt}{2.0ex}}         % = `top' strut
\newcommand\Bstrut{\rule[-0.9ex]{0pt}{0pt}}   % = `bottom' strut

%%%%%%%%%%%%%%%%%
%   Homework 1  %
%%%%%%%%%%%%%%%%%
\title{EE 382C Multicore Computing Homework 1}
\author{
    Mitchell, Olivia\\
    \texttt{ozm59}
    \and
    Molter, Matthew\\
    \texttt{mm58286}}
\date{\today}

\begin{document}
\maketitle

%%%%%%%%%%%%%%%%%
%   Problem 1   %
%%%%%%%%%%%%%%%%%
\section{Problem 1}
 You are one of $P$ recently arrested prisoners. The warden, a deranged computer engineer, makes the following announcement:
\begin{itemize}
  \item You may meet together today and plan a strategy, but after today you will be in isolated cells and have no communication with one another.
  \item I have set up a “switch room” which contains a light switch, which is either $on$ or $off$. The switch is not connected to anything.
  \item Every now and then, I will select one prisoner at random to enter the “switch room.” This prisoner may throw the switch (from $on$ to $off$, or vice-versa), or may leave the switch unchanged. Nobody else will ever enter this room.
  \item Each prisoner will visit the switch room arbitrarily often. More precisely, for any $N$, eventually each of you will visit the switch room at least $N$ times.
  \item At any time, any of you may declare: “we have all visited the switch room at least once.” If the claim is correct, I will set you free. If the claim is incorrect, I will feed all of you to the crocodiles. Choose wisely!
\end{itemize}

\begin{enumerate}[label=\alph*)]
  \item Devise a winning strategy when you know that the initial state of the switch is $off$.
  \item Devise a winning strategy when you do not know whether the initial state of the switch is $on$ or $off$.
\end{enumerate}

\subsection{Solution 1a}

\subsection{Solution 1b}

%%%%%%%%%%%%%%%%%
%   Problem 2   %
%%%%%%%%%%%%%%%%%
\pagebreak
\section{Problem 2}
Show that any of the following modifications to Peterson’s algorithm makes it incorrect:

\begin{enumerate}[label=\alph*)]
  \item A process in Peterson’s algorithm sets the $turn$ variable to itself instead of setting it to the other process.
  \item A process sets the turn variable before setting the $wantCS$ variable.
\end{enumerate}


\subsection{Solution 2a}
Take the following possible order of executions.

\begin{linenumbers}
	wantCS[0] = true;
	
	wantCS[1] = true;
	
	turn = 0; // $P_0$ enters CS since $P_1$ does not yet want to enter the CS.
	
	turn = 1; // $P_1$ enters CS. $P_0$ is already in the CS, but it is not $P_0$'s turn.
\end{linenumbers}

It can be seen that it is possible for both processes can enter the critical section at the same time. This violates mutual exclusion.

\subsection{Solution 2b}
Take the following possible order of executions.

\begin{linenumbers}
	turn = 1;
	
	turn = 0;
	
	wantCS[1] = true; // $P_1$ enters CS. It is $P_0$'s turn, but it does not want the CS.
	
	wantsCS[0] = true; // $P_0$ enters CS. $P_1$ is already in the CS, but it is not $P_1$'s turn.
\end{linenumbers}

It can be seen that it is possible for both processes can enter the critical section at the same time. This violates mutual exclusion.


%%%%%%%%%%%%%%%%%
%   Problem 3   %
%%%%%%%%%%%%%%%%%
\pagebreak
\section{Problem 3}
The $l-exclusion$ problem is a variant of the starvation-free mutual exclusion problem. We make two changes: as many as $l$ threads may be in the critical section at the same time, and fewer than $l$ threads might fail (by halting) in the critical section. An implementation must satisfy the following conditions:

\begin{description}[font=\scshape\bfseries]
\item [$l-Exclusion$:] At any time, at most $l$ threads are in the critical section.
\item [$l-Starvation-Freedom$:] As long as fewer than $l$ threads are in the critical section then some thread that wants to enter the critical section will eventually succeed (even if some threads in the critical section have halted).
\end{description}

Modify the $n$-process $Filter$ mutual exclusion algorithm to turn it into an $l-exclusion$ algorithm.

\subsection{Solution 3}
Original algorithm:

\begin{lstlisting}
defn:
int N; // number of processes
int[] gate; // for thread i, gate[i] stores gate thread i is trying to enter; init 0s
int[] last; // for gate k, last[k] stores last thread id trying to enter; init 0s

requestCS(int i):
	for(int k = 1; k < N; k++) {
		gate[i] = k;
		last[k] = i;
		for(int j = 0; j < N; j++) {
			while((j != i) && // there is some other process
				(gate[j] >= k) && // that is ahead or at the same level
				(last[k] == i)) // and I am the last to update last[k]
			{}; // busy wait
		}
	}
	
releaseCS(int i):
	gate[i] = 0;



\end{lstlisting}





%%%%%%%%%%%%%%%%%
%   Problem 4   %
%%%%%%%%%%%%%%%%%
\pagebreak
\section{Problem 4}
Write a Java class that computes frequency of an item in an array of integers. It provides the following $static$ method:

%Java code
\begin{lstlisting}[language=Java]
public class Frequency {
  public static int parallelFreq(int x, int[] A, int numThreads) {
    // your implementation goes here.
  }
}
\end{lstlisting}

This method creates as many threads as specified by $numThreads$, divides the array $A$ into that many parts, and gives each thread a part of the array. Each thread computes the frequency of $x$ in its own subarray in parallel. The method should return the overall sum of the frequencies. Use $Callable$ interface for your implementation.

%%%%%%%%%%%%%%%%%
%   Problem 5   %
%%%%%%%%%%%%%%%%%
\pagebreak
\section{Problem 5}
Write a program that uses $n$ threads, where $n = 1..8$. These threads increment a shared variable $c$. The total number of increment operations are $m = 1, 200, 000$. Each thread reads the value of $c$ and increments it $m/n$ times. Implement the following methods and compare the the total time taken for each of
the following methods for $n = 1..8$.

%Java code
\begin{lstlisting}[language=Java]
public class PIncrement {
  public static int parallelIncrement(int c, int numThreads) {
    // your implementation goes here
  }
}
\end{lstlisting}


Submit the plot as part of the assignment.

\begin{enumerate}[label=\alph*)]
  \item Peterson’s Tournament Algorithm.
  \item Java’s AtomicInteger (with $compareAndSet$ method)
  \item Java’s synchronized construct
  \item Java’s Reentrant Lock
\end{enumerate}

Remember to use $volatile$ qualifier for shared variables to guarantee
atomicity for part (a).

\subsection{Plots 5a}

\subsection{Plots 5b}

\subsection{Plots 5c}

\subsection{Plots 5d}


\end{document}
