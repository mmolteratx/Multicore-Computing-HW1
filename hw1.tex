\documentclass{article}

\usepackage[english]{babel}
\usepackage[utf8]{inputenc}
\usepackage{amsmath,amssymb}
\usepackage{parskip}
\usepackage{enumitem}
\usepackage{listings}
\usepackage{graphicx}
\usepackage[ruled,vlined]{algorithm2e}
%\usepackage{algorithmic}
%\usepackage{algpseudocode}

% Margins
\usepackage[top=2.5cm, left=3cm, right=3cm, bottom=4.0cm]{geometry}
% Colour table cells
\usepackage[table]{xcolor}

% Get larger line spacing in table
\newcommand{\tablespace}{\\[1.25mm]}
\newcommand\Tstrut{\rule{0pt}{2.6ex}}         % = `top' strut
\newcommand\tstrut{\rule{0pt}{2.0ex}}         % = `top' strut
\newcommand\Bstrut{\rule[-0.9ex]{0pt}{0pt}}   % = `bottom' strut

%%%%%%%%%%%%%%%%%
%   Homework 1  %
%%%%%%%%%%%%%%%%%
\title{EE 382C Multicore Computing Homework 1}
\author{
    Mitchell, Olivia\\
    \texttt{ozm59}
    \and
    Molter, Matthew\\
    \texttt{EID}}
\date{\today}

\begin{document}
\maketitle

%%%%%%%%%%%%%%%%%
%   Problem 1   %
%%%%%%%%%%%%%%%%%
\section{Problem 1}
 You are one of $P$ recently arrested prisoners. The warden, a deranged computer engineer, makes the following announcement:
\begin{itemize}
  \item You may meet together today and plan a strategy, but after today you will be in isolated cells and have no communication with one another.
  \item I have set up a “switch room” which contains a light switch, which is either $on$ or $off$. The switch is not connected to anything.
  \item Every now and then, I will select one prisoner at random to enter the “switch room.” This prisoner may throw the switch (from $on$ to $off$, or vice-versa), or may leave the switch unchanged. Nobody else will ever enter this room.
  \item Each prisoner will visit the switch room arbitrarily often. More precisely, for any $N$, eventually each of you will visit the switch room at least $N$ times.
  \item At any time, any of you may declare: “we have all visited the switch room at least once.” If the claim is correct, I will set you free. If the claim is incorrect, I will feed all of you to the crocodiles. Choose wisely!
\end{itemize}

\begin{enumerate}[label=\alph*)]
  \item Devise a winning strategy when you know that the initial state of the switch is $off$.
  \item Devise a winning strategy when you do not know whether the initial state of the switch is $on$ or $off$.
\end{enumerate}

\subsection{Solution 1a}

\subsection{Solution 1b}

%%%%%%%%%%%%%%%%%
%   Problem 2   %
%%%%%%%%%%%%%%%%%
\pagebreak
\section{Problem 2}
Show that any of the following modifications to Peterson’s algorithm makes it incorrect:

\begin{enumerate}[label=\alph*)]
  \item A process in Peterson’s algorithm sets the $turn$ variable to itself instead of setting it to the other process.
  \item A process sets the turn variable before setting the $wantCS$ variable.
\end{enumerate}


\subsection{Solution 2a}

\subsection{Solution 2b}


%%%%%%%%%%%%%%%%%
%   Problem 3   %
%%%%%%%%%%%%%%%%%
\pagebreak
\section{Problem 3}
The $l-exclusion$ problem is a variant of the starvation-free mutual exclusion problem. We make two changes: as many as $l$ threads may be in the critical section at the same time, and fewer than $l$ threads might fail (by halting) in the critical section. An implementation must satisfy the following conditions:

\begin{description}[font=\scshape\bfseries]
\item [$l-Exclusion$:] At any time, at most $l$ threads are in the critical section.
\item [$l-Starvation-Freedom$:] As long as fewer than $l$ threads are in the critical section then some thread that wants to enter the critical section will eventually succeed (even if some threads in the critical section have halted).
\end{description}

Modify the $n$-process $Filter$ mutual exclusion algorithm to turn it into an $l-exclusion$ algorithm.

\subsection{Solution 3}


%%%%%%%%%%%%%%%%%
%   Problem 4   %
%%%%%%%%%%%%%%%%%
\pagebreak
\section{Problem 4}
Write a Java class that computes frequency of an item in an array of integers. It provides the following $static$ method:

%Java code
\begin{lstlisting}[language=Java]
public class Frequency {
  public static int parallelFreq(int x, int[] A, int numThreads) {
    // your implementation goes here.
  }
}
\end{lstlisting}

This method creates as many threads as specified by $numThreads$, divides the array $A$ into that many parts, and gives each thread a part of the array. Each thread computes the frequency of $x$ in its own subarray in parallel. The method should return the overall sum of the frequencies. Use $Callable$ interface for your implementation.

%%%%%%%%%%%%%%%%%
%   Problem 5   %
%%%%%%%%%%%%%%%%%
\pagebreak
\section{Problem 5}
Write a program that uses $n$ threads, where $n = 1..8$. These threads increment a shared variable $c$. The total number of increment operations are $m = 1, 200, 000$. Each thread reads the value of $c$ and increments it $m/n$ times. Implement the following methods and compare the the total time taken for each of
the following methods for $n = 1..8$.

%Java code
\begin{lstlisting}[language=Java]
public class PIncrement {
  public static int parallelIncrement(int c, int numThreads) {
    // your implementation goes here
  }
}
\end{lstlisting}


Submit the plot as part of the assignment.

\begin{enumerate}[label=\alph*)]
  \item Peterson’s Tournament Algorithm.
  \item Java’s AtomicInteger (with $compareAndSet$ method)
  \item Java’s synchronized construct
  \item Java’s Reentrant Lock
\end{enumerate}

Remember to use $volatile$ qualifier for shared variables to guarantee
atomicity for part (a).

\subsection{Plots 5a}

\subsection{Plots 5b}

\subsection{Plots 5c}

\subsection{Plots 5d}


\end{document}
